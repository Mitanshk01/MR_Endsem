%Synthetic Reconstruction followed by resection
%works as of Dec 10, 2010
%use extrinsic calibration code of Yves Bouget for resection
%need to normalize the 3D coordinates after Torrtriangulate before passing
%it to resection
%used EPnP code for resection on Dec 23, 2010 and found to work as well
clear all; close all; clc;


% X = [ 
%       2, 4, 4;
%       1, 0, 3;
%      -0.2, 0, 5;
%      2, 0, 15;
%      0.3, 2, 6;
%      0.2, 4, 7;
%      1.25, 0, 6.5;
%      1.05, 0, 10;
%      2.1, 1.1, 8.25;
%      
%     ];

% ePnP does not work for the following set of planar points (June 2021)
X = [2 4 4.1;
     5 7 4.05;
     9 3 3.97;
     9 9 3.95;
     6 2 4.02;
     11 6 4.07;
     6 11 3.96;
     ];
 
Np = 15;
sx = 2;
sy = 2;
sz = 10;

%X = [sx*randn(1,Np)-1;sy*randn(1,Np)-1;sz*randn(1,Np)+6]; %This is Normal
% X = [sx*rand(1,Np)-1;sy*rand(1,Np)-1;sz*rand(1,Np)+2]; %This is pseudo rand
% X = X'; %This line is needed if X is generated by random distributions
% using commands in pevious two lines

Ka = [ 351.787   	0   	315.900;
    	0       351.787     238.966;
    	0       	0       	1];

Kb = eye(3);
    
theta = 15;
theta1 = 5;

R = [cosd(theta)    0    sind(theta); 
        0           1       0;
     -sind(theta)   0   cosd(theta)]
 
R1 = [cosd(theta1)    0    sind(theta1); 
        0           1       0;
     -sind(theta1)   0   cosd(theta1)]


 R = eye(3);

T = [2; 0; 0];
T1 = [0.25; 0.5; 0.25];

P1a = Ka*eye(3,4);
P2a = Ka * [R T];
P3a = Ka * [R1 T1];

P1b = Kb*eye(3,4);
P2b = Kb * [R T];
P3b = Kb * [R1 T1];

%Image plane co-ordinates
x1 = []; x2 = []; x3 = [];

for i=1:size(X, 1)
    p = [X(i,:)'; 1]; %4 X n
    
    x1(:, end+1) = P1a*p; %(3 X 4)X(4 X n)
    x2(:, end+1) = P2a*p;
    x3(:, end+1) = P3a*p;
    
%     x1(:, end+1) = P1b*p; %(3 X 4)X(4 X n)
%     x2(:, end+1) = P2b*p;
%     x3(:, end+1) = P3b*p;
%     
end


x1(1,:) = x1(1,:) ./ x1(3,:) ;
x2(1,:) = x2(1,:) ./ x2(3,:) ;
x3(1,:) = x3(1,:) ./ x3(3,:) ;

x1(2,:) = x1(2,:) ./ x1(3,:) ;
x2(2,:) = x2(2,:) ./ x2(3,:) ;
x3(2,:) = x3(2,:) ./ x3(3,:) ;

x1(3,:) = x1(3,:) ./ x1(3,:) ;
x2(3,:) = x2(3,:) ./ x2(3,:) ;
x3(3,:) = x3(3,:) ./ x3(3,:) ;
fprintf('actual\n');
x1
x2
x3

x1a = x1(1:2,:);% 2 X n
x2a = x2(1:2,:);
x3a = x3(1:2,:);

x1at = x1a'; % n X 2
x2at = x2a';
x3at = x3a';

matches = [x1a' x2a'];%[nX2 nX2]
matches1 = [x1a' x3a'];%[nX2 nX2]
matches2 = [x2a' x3a'];

tmp = size(x1a(1,:));
no_matches = tmp(2)

m3 = 1; %3rd homo coord 
%use Ransac to estimate F
no_samp = no_matches/2; t1 = 4; %ransac parameters
[f,f_sq_errors, n_inliers,inlier_index] = torr_mapsac_F(x1at(:,1),x1at(:,2),x2at(:,1),x2at(:,2), no_matches, m3, no_samp, t1);
[f1,f_sq_errors1, n_inliers1,inlier_index1] = torr_mapsac_F(x1at(:,1),x1at(:,2),x3at(:,1),x3at(:,2), no_matches, m3, no_samp, t1);

Fmat = [[f(1) f(2) f(3)]; [f(4) f(5) f(6)];[f(7) f(8) f(9)]];
Fmat1 = [[f1(1) f1(2) f1(3)]; [f1(4) f1(5) f1(6)];[f1(7) f1(8) f1(9)]];
%f = torr_estf(x1at(:,1),x1at(:,2),x2at(:,1),x2at(:,2), no_matches,m3)

%[F, inliers] = ransacfitfundmatrix(x1, x2, 0.001)

%e = torr_errf2(f, x1at(:,1),x1at(:,2),x2at(:,1),x2at(:,2), no_matches, m3)

homo = ones(size(x1at(:,1)));
x = [x1at homo]; %size(x1) X 3 matrix
xp = [x2at homo];
for j = 1:no_matches
    xim1 = x(j,:);
    xim2 = xp(j,:);
    epverify(j) = xim1*Fmat*xim2'; %verifies epipolar constraint
end;
epverify;
savefile = 'd:\f\codes\torrSAM\EpipolarVerify';
save(savefile, 'epverify', '-ASCII');

% x1(1,:) = x1(1,:) ./ x1(3,:) ;
% x2(1,:) = x2(1,:) ./ x2(3,:) ;
% 
% x1(2,:) = x1(2,:) ./ x1(3,:) ;
% x2(2,:) = x2(2,:) ./ x2(3,:) ;
% 
% x1(3,:) = x1(3,:) ./ x1(3,:) ;
% x2(3,:) = x2(3,:) ./ x2(3,:) ;

%Normalized co-ordinates
x1b = Ka\x1;
x2b = Ka\x2;
x3b = Ka\x3;

% x1b = Kb\x1;
% x2b = Kb\x2;
% x3b = Kb\x3;

x1n = x1b; x2n = x2b; x3n = x3b;
x1b = x1b(1:2,:);
x2b = x2b(1:2,:);
x3b = x3b(1:2,:);

figure();
hold on;
plot3(X(:,1), X(:,2), X(:,3), 'rs');
plot3(0, 0, 0, 'gs');
plot3(T(1), T(2), T(3) , 'gs');

matches = [x1b' x2b']; % from now on matches is in normalized coordinates
matches1 = [x1b' x3b']; % from now on matches is in normalized coordinates
matches2 = [x2b' x3b']; 
tmp = size(x1b(1,:));
no_matches = tmp(2);

%Xout= torr_triangulate(matches, 1, P1b, P2b);
Xgt= torr_triangulate(matches, 1, P1b, P2b); %This should simply give back X as we are using the same P's
Xgt1= torr_triangulate(matches1, 1, P1b, P3b); 
torr_display_structure(Xgt,P1b,P2b,1);
torr_display_structure(Xgt1,P1b,P3b,1);

Xgt(1,:) = Xgt(1,:) ./ Xgt(4,:);
Xgt(2,:) = Xgt(2,:) ./ Xgt(4,:);
Xgt(3,:) = Xgt(3,:) ./ Xgt(4,:);

Xgt1(1,:) = Xgt1(1,:) ./ Xgt1(4,:);
Xgt1(2,:) = Xgt1(2,:) ./ Xgt1(4,:);
Xgt1(3,:) = Xgt1(3,:) ./ Xgt1(4,:);


%now check if xFx' = 0

%get P, P' from F
% [P1,P2] = torr_PfromF(Fmat,m3);
% P1
% P2
% X = torr_triangulate(matches12, m3, P1, P2);
% X(2,:) = -X(2,:); %this is done since the image coordinate system has its +ve y along -ve y of the world coordinate system
% f1 = torr_display_structure(X, P1, P2,1);
% X(2,:) = -X(2,:);
% size(X)

%now guess the camera calibration matrix
%CC = diag(ones(3,1),0);
%CC(3,3) = 1;

%do some variable changes to make use of the cut and paste code
nF = Fmat;
nF1 = Fmat1;


%nx1 = x1; ny1 = y1; nx2 = x2; ny2 = y2;
%next self calibrate for focal length

%[focal_length, nE,CCC] = torr_self_calib_f_KMK(nF,CC);
%[focal_length, nE,CCC] = torr_self_calib_f(nF,CC);

%find E from F
Ka
Fmat
E = Ka' * Fmat * Ka
E1 = Ka'*Fmat1*Ka;

%forcing E to be rank 2
% [U,S,V] = svd(E);
% note that there is a one p[arameter family of SVD's for E
% 
% if abs(S(3,3)) > 0.00001
%     error('E must be rank 2 to self calibrate');
% end
% 
% if abs(S(1,1) - S(2,2)) > 0.00001
%     S
% %    error('E must have two equal singular values');
% end
% 
% %this a problem not pointed out in the Sturm paper, the essential matrix produced might have funny singular values
% %fix the bugga to have equal singular values:
% 
% S(3,3) = 0;
% S(1,1) = S(2,2);
% E = U*S*V';

CCC = eye(3);

%now we have an Essential matrix we can establish the camera frame...
%m3 = 1;
m3 = 1;
[P1,P2,R,t,srot_axis,rot_angle,g]  = KMKtorr_linear_EtoPX(E,matches,CCC,m3);
[P1,P3,R,t,srot_axis,rot_angle,g]  = KMKtorr_linear_EtoPX(E1,matches1,CCC,m3);

%next convert the 6 parameters of g to a fundamental matrix
%f2 = torr_g2F(g,CCC);
%disp('error before non-linear minimization')
%e = torr_errf2(f2, nx1,ny1,nx2,ny2, length(nx1), m3);
%norm(e)

%[g,f] = torr_nonlinG(g ,nx1,ny1,nx2,ny2, no_matches, m3, CCC)
%next correct the points so that they lie on the fundamental matrix
%[corrected_matches error2] = torr_correctx4F(f, nx1,ny1,nx2,ny2, no_matches, m3);


%disp('error after')
%e2 = torr_errf2(f, nx1,ny1,nx2,ny2, length(nx1), m3);
%norm(e2)

%next we need to obtain P1 & P2
%[P1, P2] = torr_g2FP(g,CCC);

%now use P matrices and corrected matches to get structure:
P1
P2
P3
% Trans21 = P2(:,4);
% Trans21(1) = Trans21(1)/Trans21(3);
% Trans21(2) = Trans21(2)/Trans21(3);
% Trans21(3) = Trans21(3)/Trans21(3);
% 
% Trans31 = P3(:,4);
% Trans31(1) = Trans31(1)/Trans31(3);
% Trans31(2) = Trans31(2)/Trans31(3);
% Trans31(3) = Trans31(3)/Trans31(3);
% 
% Trans21
% Trans31

Xout = torr_triangulate(matches, m3, P1, P2);
Xout1 = torr_triangulate(matches1, m3, P1, P3);

%note structure is upside down!

%test reprojection error
% rx1 = (P1 * X)';
% 
% rx1(:,1) = m3 * rx1(:,1) ./ rx1(:,3);
% rx1(:,2) = m3 * rx1(:,2) ./ rx1(:,3);
% 
% rx2 = P2 * X;

%inlier_index = torr_robust_chieral(X,P1,P2);

%disp('number of outliers from chierality:')
%no_matches - length(inlier_index)

%X = X(:,inlier_index);
%flash up a new window and display the structure plus cameras:
%invert = 1;

% note becuase of row/column coordinate system of the image the X's are upside down so invert them prior
% to display.
%X(2,:) = -X(2,:);
torr_display_structure(Xout, P1, P2);
torr_display_structure(Xout1, P1, P3);


Xout(1,:) = Xout(1,:) ./ Xout(4,:);
Xout(2,:) = Xout(2,:) ./ Xout(4,:);
Xout(3,:) = Xout(3,:) ./ Xout(4,:);
Xout(4,:) = Xout(4,:) ./ Xout(4,:);
Xout

Xout1(1,:) = Xout1(1,:) ./ Xout1(4,:);
Xout1(2,:) = Xout1(2,:) ./ Xout1(4,:);
Xout1(3,:) = Xout1(3,:) ./ Xout1(4,:);
Xout1(4,:) = Xout1(4,:) ./ Xout1(4,:);
Xout1

scale = Xout1(:,1)./Xout(:,1);
sc = scale(1:3)
P3(:,4) = P3(:,4)./sc;

T31 = [P3; 0 0 0 1]; 
T13 = eye(4,4)/T31;
T21 = [P2; 0 0 0 1];
T12 = eye(4,4)/T21;
T23 = T21*T13;
T32 = T31*T12;
P4 = eye(3,4);
P5 = T32(1:3,:)

Xout2 = torr_triangulate(matches2, m3, P4, P5);
%torr_display_structure(Xout2, P4, P5);

Xout2(1,:) = Xout2(1,:) ./ Xout2(4,:);
Xout2(2,:) = Xout2(2,:) ./ Xout2(4,:);
Xout2(3,:) = Xout2(3,:) ./ Xout2(4,:);
Xout2(4,:) = Xout2(4,:) ./ Xout2(4,:);

Xoutg = T12*Xout2 %This finally represents reconstructed points from im2 and im3 in global frame or frame of im1 with the unified scale
KMKtorr_display_structure(Xoutg);

%X(2,:) = -X(2,:);
%[omckk,Tckk,Rckk,H,x,ex,JJ] = compute_extrinsic(x2b,Xout(1:3,:));
cc = [315.9 238.966];
Xact = X';
%[omckk,Tckk,Rckk,H,x,ex,JJ] = compute_extrinsic(x2a,Xout(1:3,:),[351.787 351.787],cc);

%EPnP code for resection
%function [R,T,Xc,best_solution]=efficient_pnp(x3d_h,x2d_h,A)
%       x3d_h: homogeneous coordinates of the points in world reference
%       x2d_h: homogeneous position of the points in the image plane
%       A: intrincic camera parameters
%       R: Rotation of the camera system wrt world reference
%       T: Translation of the camera system wrt world reference
%       Xc: Position of the points in the camera reference


%[Rot,Trans,Xc,best_solution]=efficient_pnp(Xout',x2',Ka);
[Rot,Trans,Xc,best_solution]=efficient_pnp(Xout',x2n',Kb); % Note either above command or the current gives same Rot, Trans. Note the change from x2 ->x2n and Ka->Kb
Rot1 = Rot;
Trans1 = Trans;
% size(Xout')
% size(x2')
% size(Ka)
[Rot,Trans,Xc,best_solution]=efficient_pnp(Xout1',x3n',Kb); % Note either above command or the current gives same Rot, Trans. Note the change from x2 ->x2n and Ka->Kb
Rot = Rot;
Trans = Trans;

[Rot,Trans,Xc,best_solution]=efficient_pnp(Xoutg',x2n',Kb); % Note either above command or the current gives same Rot, Trans. Note the change from x2 ->x2n and Ka->Kb
Rotg = Rot
Transg = Trans
R
T

[Rot,Trans,Xc,best_solution]=efficient_pnp(Xoutg',x3n',Kb); % Note either above command or the current gives same Rot, Trans. Note the change from x2 ->x2n and Ka->Kb
Rotg1 = Rot
Transg1 = Trans
R1
T1
